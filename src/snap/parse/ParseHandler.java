/*
 * Copyright (c) 2010, ReportMill Software. All rights reserved.
 */
package snap.parse;

/**
 * A class called when child rules are parsed.
 */
public class ParseHandler<T> {

    // The part generated by this handler
    protected T  _part;

    // The token where the current part started
    private ParseToken _startToken;

    // Whether handler is in use
    private boolean  _inUse;

    // Whether handler has been told to bypass further rules
    private boolean  _bypass;

    // Whether handler has been told to fail
    private boolean  _fail;

    // The backup handler
    protected ParseHandler  _backupHandler;

    /**
     * Called when a child rule has been successfully parsed into given node.
     */
    protected void parsedOne(ParseNode aNode)
    {
        if (_startToken == null) _startToken = aNode.getStartToken();
        parsedOne(aNode, aNode.getId());
    }

    /**
     * Called when a child rule has been successfully parsed into given node.
     */
    protected void parsedOne(ParseNode aNode, String anId)  { }

    /**
     * Called when all child rules have been successfully parsed.
     */
    public T parsedAll()
    {
        T part = _part;
        reset();
        return part;
    }

    /**
     * Returns the part.
     */
    public T getPart()
    {
        return _part != null ? _part : (_part = createPart());
    }

    /**
     * Creates the part.
     */
    protected T createPart()
    {
        try { return getPartClass().newInstance(); }
        catch (Exception e) { throw new RuntimeException(e); }
    }

    /**
     * Returns the part class.
     */
    protected Class<T> getPartClass()
    {
        throw new RuntimeException(getClass().getName() + ".getPartClass: Not implemented");
        //return getTypeParameterClass(getClass());
    }

    /**
     * Returns the token where the current part started.
     */
    public ParseToken getStartToken()  { return _startToken; }

    /**
     * Whether parsing should bypass succeeding rules.
     */
    public boolean isBypass()  { return _bypass; }

    /**
     * Indicates that parsing should short circuit.
     */
    public void bypass()  { _bypass = true; }

    /**
     * Whether parsing should fail on current rule.
     */
    public boolean isFail()  { return _fail; }

    /**
     * Indicates that parsing should fail on current rule.
     */
    public void fail()  { _fail = true; }

    /**
     * Returns a handler that is not in use.
     * This method should be synchronized, but that makes TeaVM unhappy.
     */
    public ParseHandler getAvailableHandler()
    {
        ParseHandler handler = this;
        while (handler._inUse)
            handler = handler.getBackupHandler();
        handler._inUse = true;
        return handler;
    }

    /**
     * Returns a backup handler.
     */
    protected ParseHandler getBackupHandler()
    {
        // If already set, just return
        if (_backupHandler != null) return _backupHandler;

        // Create, set and return
        return _backupHandler = createBackupHandler();
    }

    /**
     * Returns a backup handler.
     */
    protected ParseHandler createBackupHandler()
    {
        // Create and return
        try { return getClass().newInstance(); }
        catch (InstantiationException e) { throw new RuntimeException(e); }
        catch (IllegalAccessException e) { throw new RuntimeException(e); }
    }

    /**
     * Resets the handler.
     */
    public void reset()
    {
        _part = null;
        _startToken = null;
        _inUse = _bypass = _fail = false;
    }
}